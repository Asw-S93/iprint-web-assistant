<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iPrint Web Assistant v2.2</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; max-width: 600px; margin: 20px auto; padding: 0 15px; line-height: 1.6; background-color: #f4f7f9; color: #333; }
        .card { background: white; border: 1px solid #e1e4e8; padding: 25px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.05); margin-bottom: 20px; }
        h1 { color: #1a73e8; text-align: center; margin-bottom: 5px; }
        .version { text-align: center; font-size: 12px; color: #9aa0a6; margin-bottom: 20px; }
        h3 { margin-top: 0; color: #555; border-bottom: 2px solid #f0f2f5; padding-bottom: 10px; }
        button { background: #1a73e8; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: 600; width: 100%; transition: background 0.2s; margin-bottom: 10px; }
        button:hover { background: #1557b0; }
        button:disabled { background: #bdc3c7; cursor: not-allowed; }
        .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px; }
        .btn-secondary { background: #f1f3f4; color: #3c4043; border: 1px solid #dadce0; }
        textarea, input[type="file"], select { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; box-sizing: border-box; margin-bottom: 10px; }
        .log { background: #202124; color: #f1f3f4; padding: 15px; border-radius: 8px; font-family: monospace; height: 180px; overflow-y: auto; font-size: 11px; border-left: 4px solid #1a73e8; }
        .preview-container { text-align: center; margin: 10px 0; background: #eee; padding: 10px; border-radius: 8px; overflow-x: auto; }
        #previewCanvas { background: white; border: 1px solid #ccc; image-rendering: pixelated; }
        .option-group { display: flex; gap: 10px; align-items: center; margin-bottom: 10px; font-size: 14px; flex-wrap: wrap; }
    </style>
</head>
<body>
    <h1>iPrint Assistant ðŸ”‘</h1>
    <div class="version">Build v2.2 (Stability & Bug Fix)</div>

    <div class="card">
        <h3>1. Connection</h3>
        <button id="connectBtn">Connect to Printer</button>
        <div id="connectionStatus" style="font-size:12px; margin-top:5px; color:#666;">Not connected</div>
    </div>

    <div class="card" style="background: #e3f2fd; border: 1px solid #90caf9;">
        <h3>2. Calibration</h3>
        <div class="option-group">
            <label>Width:</label>
            <select id="printWidth" style="width:auto;">
                <option value="384">384px</option>
                <option value="576" selected>576px (SC03h)</option>
            </select>
            <label>Bit Order:</label>
            <select id="bitOrder" style="width:auto;">
                <option value="msb" selected>MSB (Standard)</option>
                <option value="lsb">LSB (Alternate)</option>
            </select>
        </div>
        <div class="option-group">
            <label>Contrast:</label>
            <input type="range" id="threshold" min="0" max="255" value="128" style="width:100px;">
            <label>Dithering:</label>
            <select id="ditherMode" style="width:auto;">
                <option value="none">None</option>
                <option value="floyd" selected>Floyd-Steinberg</option>
            </select>
            <label><input type="checkbox" id="invertCheck"> Invert</label>
        </div>
        <div class="controls">
            <button id="feedBtn" class="btn-secondary" disabled>Feed Paper</button>
            <button id="resetBtn" class="btn-secondary" disabled>Reset Hardware</button>
        </div>
    </div>

    <div class="card">
        <h3>3. Print Job</h3>
        <input type="file" id="imageInput" accept="image/*">
        <textarea id="textInput" placeholder="Enter text here...">Hello Sambhav!</textarea>
        
        <div class="preview-container">
            <canvas id="previewCanvas" width="576"></canvas>
        </div>
        
        <button id="printBtn" disabled style="background: #34a853;">START PRINTING</button>
    </div>

    <div class="card">
        <h3>System Log</h3>
        <div id="log" class="log"></div>
    </div>

    <script>
        const KNOWN_SERVICES = ['0000ae30-0000-1000-8000-00805f9b34fb', '0000fee7-0000-1000-8000-00805f9b34fb'];
        const CRC_TABLE = new Uint8Array([0x00, 0x07, 0x0E, 0x09, 0x1C, 0x1B, 0x12, 0x15, 0x38, 0x3F, 0x36, 0x31, 0x24, 0x23, 0x2A, 0x2D, 0x70, 0x77, 0x7E, 0x79, 0x6C, 0x6B, 0x62, 0x65, 0x48, 0x4F, 0x46, 0x41, 0x54, 0x53, 0x5A, 0x5D, 0xE0, 0xE7, 0xEE, 0xE9, 0xFC, 0xFB, 0xF2, 0xF5, 0xD8, 0xDF, 0xD6, 0xD1, 0xC4, 0xC3, 0xCA, 0xCD, 0x90, 0x97, 0x9E, 0x99, 0x8C, 0x8B, 0x82, 0x85, 0xA8, 0xAF, 0xA6, 0xA1, 0xB4, 0xB3, 0xBA, 0xBD, 0xC7, 0xC0, 0xC9, 0xCE, 0xDB, 0xDC, 0xD5, 0xD2, 0xFF, 0xF8, 0xF1, 0xF6, 0xE3, 0xE4, 0xED, 0xEA, 0xB7, 0xB0, 0xB9, 0xBE, 0xAB, 0xAC, 0xA5, 0xA2, 0x8F, 0x88, 0x81, 0x86, 0x93, 0x94, 0x9D, 0x9A, 0x27, 0x20, 0x29, 0x2E, 0x3B, 0x3C, 0x35, 0x32, 0x1F, 0x18, 0x11, 0x16, 0x03, 0x04, 0x0D, 0x0A, 0x57, 0x50, 0x59, 0x5E, 0x4B, 0x4C, 0x45, 0x42, 0x6F, 0x68, 0x61, 0x66, 0x73, 0x74, 0x7D, 0x7A, 0x89, 0x8E, 0x87, 0x80, 0x95, 0x92, 0x9B, 0x9C, 0xB1, 0xB6, 0xBF, 0xB8, 0xAD, 0xAA, 0xA3, 0xA4, 0xF9, 0xFE, 0xF7, 0xF0, 0xE5, 0xE2, 0xEB, 0xEC, 0xC1, 0xC6, 0xCF, 0xC8, 0xDD, 0xDA, 0xD3, 0xD4, 0x69, 0x6E, 0x67, 0x60, 0x75, 0x72, 0x7B, 0x7C, 0x51, 0x56, 0x5F, 0x58, 0x4D, 0x4A, 0x43, 0x44, 0x19, 0x1E, 0x17, 0x10, 0x05, 0x02, 0x0B, 0x0C, 0x21, 0x26, 0x2F, 0x28, 0x3D, 0x3A, 0x33, 0x34, 0x4E, 0x49, 0x40, 0x47, 0x52, 0x55, 0x5C, 0x5B, 0x76, 0x71, 0x78, 0x7F, 0x6A, 0x6D, 0x64, 0x63, 0x3E, 0x39, 0x30, 0x37, 0x22, 0x25, 0x2C, 0x2B, 0x06, 0x01, 0x08, 0x0F, 0x1A, 0x1D, 0x14, 0x13, 0xAE, 0xA9, 0xA0, 0xA7, 0xB2, 0xB5, 0xBC, 0xBB, 0x96, 0x91, 0x98, 0x9F, 0x8A, 0x8D, 0x84, 0x83, 0xDE, 0xD9, 0xD0, 0xD7, 0xC2, 0xC5, 0xCC, 0xCB, 0xE6, 0xE1, 0xE8, 0xEF, 0xFA, 0xFD, 0xF4, 0xF3]);

        let device, writeChar;
        const canvas = document.getElementById('previewCanvas');
        const ctx = canvas.getContext('2d');
        const log = (msg) => { document.getElementById('log').innerHTML += `[${new Date().toLocaleTimeString()}] ${msg}<br>`; document.getElementById('log').scrollTop = document.getElementById('log').scrollHeight; };
        const updateUI = (connected) => {
            document.getElementById('connectBtn').innerText = connected ? 'Disconnect' : 'Connect to Printer';
            ['feedBtn', 'resetBtn', 'printBtn'].forEach(id => document.getElementById(id).disabled = !connected);
            document.getElementById('connectionStatus').innerText = connected ? `Connected: ${device.name}` : 'Not connected';
        };

        const calcCrc = (data) => { let crc = 0; for (let b of data) crc = CRC_TABLE[crc ^ b]; return crc; };
        const createPacket = (cmd, data = []) => {
            const dataLen = data.length;
            const packet = new Uint8Array(8 + dataLen);
            packet[0] = 0x51; packet[1] = 0x78; packet[2] = cmd; packet[3] = 0x00;
            packet[4] = dataLen & 0xFF; packet[5] = (dataLen >> 8) & 0xFF;
            packet.set(data, 6);
            packet[6 + dataLen] = calcCrc(data);
            packet[7 + dataLen] = 0xFF;
            return packet;
        };

        document.getElementById('connectBtn').onclick = async () => {
            if (device && device.gatt.connected) { device.gatt.disconnect(); updateUI(false); return; }
            try {
                device = await navigator.bluetooth.requestDevice({ acceptAllDevices: true, optionalServices: KNOWN_SERVICES });
                const server = await device.gatt.connect();
                await new Promise(r => setTimeout(r, 1000));
                const services = await server.getPrimaryServices();
                for (const s of services) {
                    const chars = await s.getCharacteristics();
                    for (const c of chars) {
                        if (c.properties.write || c.properties.writeWithoutResponse) { writeChar = c; break; }
                    }
                    if (writeChar) break;
                }
                if (writeChar) { log('Ready!'); updateUI(true); renderPreview(); }
            } catch (e) { log(`Error: ${e.message}`); }
        };

        async function sendBytes(data) {
            const mtu = 20;
            for (let i = 0; i < data.length; i += mtu) {
                const chunk = data.slice(i, i + mtu);
                try { await writeChar.writeValueWithResponse(chunk); }
                catch { await writeChar.writeValueWithoutResponse(chunk); }
                await new Promise(r => setTimeout(r, 15));
            }
        }

        function renderPreview() {
            const text = document.getElementById('textInput').value;
            const imgFile = document.getElementById('imageInput').files[0];
            const width = parseInt(document.getElementById('printWidth').value);
            const threshold = parseInt(document.getElementById('threshold').value);
            const dither = document.getElementById('ditherMode').value;
            const invertCheck = document.getElementById('invertCheck');
            const invert = invertCheck ? invertCheck.checked : false;

            canvas.width = width;
            if (imgFile) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const h = Math.round(img.height * (width / img.width));
                        canvas.height = h;
                        ctx.fillStyle = "white"; ctx.fillRect(0,0,width,h);
                        ctx.drawImage(img, 0, 0, width, h);
                        processCanvas(invert, threshold, dither);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(imgFile);
            } else {
                const lines = text.split('\n');
                canvas.height = lines.length * 40 + 20;
                ctx.fillStyle = "white"; ctx.fillRect(0,0,width,canvas.height);
                ctx.fillStyle = "black"; ctx.font = "bold 32px sans-serif";
                lines.forEach((line, i) => ctx.fillText(line, 10, 40 + i * 40));
                processCanvas(invert, threshold, dither);
            }
        }

        function processCanvas(invert, threshold, dither) {
            const idata = ctx.getImageData(0,0,canvas.width,canvas.height);
            const data = idata.data;
            if (dither === 'floyd') {
                for (let y = 0; y < canvas.height; y++) {
                    for (let x = 0; x < canvas.width; x++) {
                        const i = (y * canvas.width + x) * 4;
                        const oldPixel = (data[i] + data[i+1] + data[i+2]) / 3;
                        const newPixel = oldPixel < threshold ? 0 : 255;
                        const error = oldPixel - newPixel;
                        data[i] = data[i+1] = data[i+2] = newPixel;
                        distributeError(x, y, error, data, canvas.width);
                    }
                }
            } else {
                for(let i=0; i<data.length; i+=4) {
                    const avg = (data[i] + data[i+1] + data[i+2]) / 3;
                    const val = avg < threshold ? 0 : 255;
                    data[i] = data[i+1] = data[i+2] = val;
                }
            }
            if (invert) {
                for(let i=0; i<data.length; i+=4) {
                    data[i] = 255-data[i]; data[i+1] = 255-data[i+1]; data[i+2] = 255-data[i+2];
                }
            }
            ctx.putImageData(idata, 0, 0);
        }

        function distributeError(x, y, error, data, w) {
            const add = (nx, ny, weight) => {
                if (nx < 0 || nx >= w || ny >= canvas.height) return;
                const i = (ny * w + nx) * 4;
                const val = (data[i] + data[i+1] + data[i+2])/3 + error * weight;
                data[i] = data[i+1] = data[i+2] = Math.max(0, Math.min(255, val));
            };
            add(x + 1, y, 7/16); add(x - 1, y + 1, 3/16); add(x, y + 1, 5/16); add(x + 1, y + 1, 1/16);
        }

        ['textInput', 'imageInput', 'invertCheck', 'threshold', 'printWidth', 'ditherMode'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.oninput = renderPreview;
                el.onchange = renderPreview;
            }
        });

        document.getElementById('printBtn').onclick = async () => {
            const width = parseInt(document.getElementById('printWidth').value);
            const bitOrder = document.getElementById('bitOrder').value;
            const rowLen = width / 8;
            log(`Starting calibrated print...`);
            
            await sendBytes(createPacket(0xA4, [0x35])); 
            
            const imgData = ctx.getImageData(0, 0, width, canvas.height).data;
            for (let row = 0; row < canvas.height; row++) {
                const rowBytes = new Uint8Array(rowLen);
                let hasData = false;
                for (let col = 0; col < width; col++) {
                    const idx = (row * width + col) * 4;
                    if (imgData[idx] < 128) {
                        const bitPos = col % 8;
                        const byteIdx = Math.floor(col / 8);
                        if (bitOrder === 'msb') rowBytes[byteIdx] |= (0x80 >> bitPos);
                        else rowBytes[byteIdx] |= (0x01 << bitPos);
                        hasData = true;
                    }
                }
                if (hasData) await sendBytes(createPacket(0xA2, rowBytes));
                else await sendBytes(createPacket(0xA1, [0x01, 0x00])); 
            }
            await sendBytes(createPacket(0xA1, [0x80, 0x00])); 
            log('Done!');
        };

        document.getElementById('feedBtn').onclick = () => sendBytes(createPacket(0xA1, [0x80, 0x00]));
        document.getElementById('resetBtn').onclick = () => sendBytes(new Uint8Array([0x1B, 0x40]));
    </script>
</body>
</html>
